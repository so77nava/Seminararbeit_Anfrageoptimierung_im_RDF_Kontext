\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{csquotes}
\usepackage[style=numeric]{biblatex}
\addbibresource{literatur.bib}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  breaklines=true,
  frame=single
  language=SPARQL,
  morekeywords={SELECT, WHERE, FILTER, ORDER BY, DESC, OPTIONAL, UNION, CONSTRUCT, ASK, DESCRIBE, GRAPH, BIND, VALUES, SERVICE},
}


\title{Anfrageoptimierung im RDF-Kontext}
\author{Samuel Jordan Ouabo}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

% ---------------------- Kapitel 1 ------------------------
\section{Einleitung}

Das World Wide Web hat sich in den letzten Jahrzehnten grundlegend gewandelt: Von einer rein hypertextbasierten Dokumentensammlung hin zu einem semantisch vernetzten Informationsraum, der nicht nur für Menschen, sondern auch für Maschinen interpretierbar ist. Diese Entwicklung mündet in der Vision des \textit{Semantic Web}, wie sie von Berners-Lee formuliert wurde – ein Web, in dem Daten nicht nur dargestellt, sondern auch verarbeitet und logisch verknüpft werden können \cite{berners2001semantic}.

Ein zentrales Element des Semantic Web ist das \textit{Resource Description Framework (RDF)}, das Daten in Form von sogenannten Tripeln repräsentiert. Jedes Tripel besteht aus Subjekt, Prädikat und Objekt und bildet damit eine atomare Aussage über eine Ressource. In der Praxis entstehen durch RDF große, heterogene Graphstrukturen – sogenannte Wissensgraphen –, die in Bereichen wie Linked Data, Bioinformatik, maschinelles Lernen oder öffentliche Verwaltung eingesetzt werden \cite{hogan2021knowledge}. Zur Abfrage solcher Graphen dient die standardisierte Sprache \textit{SPARQL}, die auf dem Prinzip des \textit{Graph Pattern Matching} basiert.

Mit der wachsenden Verbreitung von RDF-basierten Datenbanken (auch als Triple Stores bezeichnet) stellt sich zunehmend die Frage, wie solche Systeme performant und skalierbar Anfragen verarbeiten können. Anders als relationale Datenbanksysteme verfügen RDF-Stores jedoch über keine feste Schemadefinition, sondern arbeiten unter der \textit{Open World Assumption} (OWA). Diese Eigenschaften erschweren die Anwendung klassischer Optimierungskonzepte erheblich: Typische Verfahren wie Kostenmodelle, Kardinalitätsschätzungen oder regelbasierte Transformationsstrategien stoßen im RDF-Kontext häufig an ihre Grenzen \cite{wylot2018rdf, ycy2015}.

Die klassische Datenbankforschung – etwa wie sie von Kemper und Eickler beschrieben wurde – hat über Jahrzehnte eine Vielzahl bewährter Methoden für die relationale Anfrageverarbeitung entwickelt \cite{kemper2022datenbanksysteme}. Zu diesen zählen algebraische Anfragepläne, dynamische Join-Reihenfolgenoptimierung und komplexe Indexierungsstrategien. Diese Techniken bilden einen wichtigen Referenzrahmen für die Frage, inwiefern und unter welchen Bedingungen sie sich auch im semantischen Kontext übertragen oder adaptieren lassen.

Ziel dieser Seminararbeit ist es, einen systematischen Überblick über Optimierungsstrategien im RDF-Kontext zu geben. Dazu werden zunächst die Grundlagen der relationalen Anfrageverarbeitung (Kapitel~\ref{sec:relational}) vorgestellt und mit dem RDF-Datenmodell und SPARQL verglichen (Kapitel~\ref{sec:rdf}). Darauf aufbauend werden die spezifischen Optimierungsprobleme und -ansätze in RDF-Datenbanken analysiert (Kapitel~\ref{sec:probleme} und~\ref{sec:ansaetze}). Abschließend erfolgt eine vergleichende Einordnung klassischer und semantischer Optimierungsprinzipien (Kapitel~\ref{sec:vergleich}) sowie eine kritische Diskussion aktueller Limitationen und zukünftiger Forschungsfragen (Kapitel~\ref{sec:diskussion} und~\ref{sec:fazit}).

% ---------------------- Kapitel 2 ------------------------

\section{Grundlagen relationaler Anfrageverarbeitung}

Die relationale Anfrageverarbeitung bildet das Rückgrat klassischer Datenbanksysteme. Ziel ist es, Anfragen – typischerweise in der Sprache SQL formuliert – unabhängig von der physischen Speicherung effizient auszuführen. Grundlage hierfür ist eine mehrstufige Verarbeitungspipeline, die unter anderem durch Kemper und Eickler systematisch dargestellt wird \cite{kemper2022datenbanksysteme}.

\subsection{Anfragebearbeitungsprozess}

Die Bearbeitung einer SQL-Anfrage erfolgt üblicherweise in drei Hauptphasen:

\begin{enumerate}
    \item \textbf{Anfrageübersetzung:} Die SQL-Anfrage wird in einen sogenannten \emph{algebraischen Anfragebaum} übersetzt. Dieser dient als interne Repräsentation und basiert auf Operatoren der relationalen Algebra (z.\,B. $\sigma$ für Selektion, $\pi$ für Projektion, $\bowtie$ für Join).
    
    \item \textbf{Anfrageoptimierung:} Der Anfragebaum wird durch Transformationen in eine äquivalente, aber effizienter auszuführende Variante überführt. Dies kann regelbasiert (durch algebraische Umformungsregeln) oder kostenbasiert (unter Zuhilfenahme eines Kostenmodells) erfolgen.
    
    \item \textbf{Anfrageausführung:} Der optimierte Anfrageplan wird anschließend vom DBMS durch konkrete Zugriffe auf Tabellen, Indizes und Pufferspeicherstrukturen ausgeführt.
\end{enumerate}

\subsection{Relationale Algebra}

Die relationale Algebra stellt eine formale Grundlage für Anfragen dar. Sie umfasst zentrale Operatoren:

\begin{itemize}
    \item \textbf{Selektion ($\sigma$):} Filtert Tupel auf Basis eines Prädikats, z.\,B. $\sigma_{note > 2.0}(\text{Klausuren})$.
    \item \textbf{Projektion ($\pi$):} Reduziert die Attributmenge, z.\,B. $\pi_{\text{name, note}}(\text{Klausuren})$.
    \item \textbf{Join ($\bowtie$):} Verknüpft zwei Relationen über gemeinsame Attribute, z.\,B. $\text{Studenten} \bowtie_{\text{matrNr}} \text{Klausuren}$.
    \item \textbf{Mengenoperationen:} Union, Differenz und kartesisches Produkt.
\end{itemize}

Die Kombination dieser Operatoren in einem Baum hat großen Einfluss auf die Effizienz – insbesondere, wenn redundante Zwischenresultate vermieden werden.

\subsection{Optimierungsstrategien}

Ziel der Anfrageoptimierung ist es, einen möglichst kostengünstigen Ausführungsplan zu generieren. Dazu kommen zwei Hauptstrategien zum Einsatz:

\begin{itemize}
    \item \textbf{Regelbasierte Optimierung:} Transformation des Anfragebaums anhand äquivalenter Umschreibungen. Beispiele sind das Vorziehen selektiver Operationen (``Selektion vor Join'') oder Projektionsreduktionen zur Verkleinerung der Zwischenergebnisse.
    
    \item \textbf{Kostenbasierte Optimierung:} Hierbei werden Statistiken über Tupelanzahl, Kardinalitäten und Indizes genutzt, um die geschätzten Kosten alternativer Pläne zu bewerten. Das Ziel ist, den optimalen Plan mit minimalem Ressourcenverbrauch auszuwählen.
\end{itemize}

Ein klassisches Beispiel für kostenbasierte Optimierung ist der \emph{System R Optimizer}, der mittels dynamischer Programmierung die optimale Join-Reihenfolge bestimmt \cite{selinger1979access}.

\subsection{Einflussfaktoren auf die Performanz}

Die Ausführungszeit einer Anfrage hängt von zahlreichen Systemaspekten ab:

\begin{itemize}
    \item \textbf{Indexierung:} Beschleunigt den Zugriff auf einzelne Tupel oder Wertebereiche.
    \item \textbf{Buffer Management:} Vermeidet unnötigen Festplattenzugriff durch intelligenten Umgang mit dem Hauptspeicher.
    \item \textbf{Parallelisierung:} Nutzt mehrere CPU-Kerne zur gleichzeitigen Ausführung von Teilplänen.
    \item \textbf{Materialisierung vs. Pipelinierung:} Unterschiedliche Strategien zur Auswertung mehrstufiger Operatorbäume.
\end{itemize}

\subsection{IDB und EDB: Relevanz für Optimierung}

In der Datalog-Theorie wird zwischen der \emph{Extensional Database (EDB)} – also den gespeicherten Basisdaten – und der \emph{Intensional Database (IDB)} – abgeleiteten Daten aus Regeln – unterschieden. Diese Konzepte sind insbesondere bei rekursiven Abfragen relevant.

Beispiel: In einem Regelwerk könnte die transitiv abgeschlossene ``Vorgesetztenbeziehung'' durch rekursive Regeln aus einfachen ``Chef von''-Tripeln berechnet werden – ähnlich wie SPARQL \texttt{PROPERTY PATHS} dies im RDF-Kontext ermöglichen. Optimierungsstrategien müssen in solchen Fällen den Fixpunktalgorithmus berücksichtigen.

% ---------------------- Kapitel 3 ------------------------
\section{RDF \& SPARQL – Datenmodell und Anfrageverarbeitung} \label{sec:rdf}

Das \textit{Resource Description Framework (RDF)} ist ein standardisiertes Datenmodell zur Repräsentation strukturierter Informationen im Web. Es bildet die Grundlage des Semantic Web und ermöglicht die Modellierung von Aussagen über Ressourcen in Form von Tripeln. Die zugehörige Anfragesprache \textit{SPARQL} erlaubt das gezielte Durchsuchen solcher RDF-Graphen und stellt somit das Gegenstück zu SQL im relationalen Kontext dar.

\subsection{RDF: Struktur und Semantik}

RDF beschreibt Informationen durch atomare Aussagen in der Form eines Tripels: \textit{(Subjekt, Prädikat, Objekt)}. Diese Tripel lassen sich als gerichtete, beschriftete Kanten in einem Graphen interpretieren. Subjekt und Objekt sind Ressourcen (identifiziert durch URIs) oder Literale; das Prädikat beschreibt die Beziehung zwischen ihnen.

\begin{lstlisting}[caption=Beispielhafte RDF-Repräsentation einer Einwohnerzahl]
dbr:Erlangen dbo:populationTotal "114257"^^xsd:nonNegativeInteger .
\end{lstlisting}

RDF ist schemalos, kann aber mithilfe von \textit{RDF Schema (RDFS)} und der \textit{Web Ontology Language (OWL)} um Typinformationen, Klassenhierarchien und logische Einschränkungen ergänzt werden. Diese ermöglichen auch Inferenzregeln, wie z.\,B. das automatische Ableiten transitiver Beziehungen \cite{antonellini2015owl}.

\subsection{Open World Assumption (OWA)}

Ein zentrales semantisches Prinzip von RDF ist die \textit{Open World Assumption} (OWA): Das Fehlen einer Aussage bedeutet nicht, dass sie falsch ist – sondern lediglich, dass nichts darüber bekannt ist. Dieses Prinzip steht im Gegensatz zur \textit{Closed World Assumption (CWA)} relationaler Systeme, wo nicht gespeicherte Fakten implizit als falsch betrachtet werden. Die OWA wirkt sich direkt auf Optimierungsstrategien aus, da beispielsweise Filterelimination oder Join-Elimination nicht ohne Weiteres möglich sind.

\subsection{SPARQL: Abfragesprache für RDF}

SPARQL (SPARQL Protocol and RDF Query Language) ist die standardisierte Sprache zur Abfrage von RDF-Daten. SPARQL-Anfragen bestehen aus \textit{Graph Patterns}, die über Variablen definiert werden und mit Tripeln in der Datenbasis abgeglichen werden.

\begin{lstlisting}[caption=SPARQL-Abfrage nach Städten mit mehr als 100.000 Einwohnern]
SELECT ?city ?population WHERE {
  ?city rdf:type dbo:City .
  ?city dbo:country dbr:Germany .
  ?city dbo:populationTotal ?population .
  FILTER (?population > 100000)
}
ORDER BY DESC(?population)
\end{lstlisting}

SPARQL unterstützt vier Haupttypen von Anfragen:
\begin{itemize}
    \item \textbf{SELECT:} Liefert Bindungen für Variablen.
    \item \textbf{ASK:} Gibt einen Wahrheitswert zurück.
    \item \textbf{CONSTRUCT:} Generiert neue RDF-Tripel.
    \item \textbf{DESCRIBE:} Liefert eine Beschreibung einer Ressource.
\end{itemize}

Darüber hinaus erlaubt SPARQL komplexe Konstrukte wie \texttt{OPTIONAL} (äquivalent zu \textit{left outer joins}), \texttt{UNION}, \texttt{FILTER} sowie \texttt{PROPERTY PATHS} zur Navigation in RDF-Graphen.

\subsection{Anfrageverarbeitung in RDF-Datenbanken}

RDF-DBMS (z.\,B. Apache Jena, Virtuoso, Blazegraph) verarbeiten SPARQL-Anfragen in mehreren Schritten:

\begin{enumerate}
    \item \textbf{Parsing:} Die SPARQL-Anfrage wird in eine interne Repräsentation überführt.
    \item \textbf{Optimierung:} Der Anfragebaum wird hinsichtlich Filterplatzierung, Join-Reihenfolge und Pattern-Gruppe analysiert.
    \item \textbf{Ausführung:} Die optimierte Anfrage wird über spezialisierte Speicherstrukturen (z.\,B. Triple Tables, Hexastore) ausgeführt.
\end{enumerate}

Ein zentrales Problem besteht in der \textbf{hohen Joindichte}: Selbst einfache Abfragen erfordern mehrere Joins, da RDF keine Attributtabellen, sondern atomare Aussagen nutzt. Dadurch entstehen viele Kanten im Anfragegraphen – mit teils erheblichem Einfluss auf die Laufzeit.

\subsection{Technische Besonderheiten RDF-basierter Systeme}

Im Gegensatz zu relationalen Datenbanken setzen RDF-Systeme auf spezielle Speicherstrukturen:
\begin{itemize}
    \item \textbf{Triple Table:} Speicherung aller Tripel in einer dreispaltigen Tabelle (Subjekt, Prädikat, Objekt).
    \item \textbf{Vertical Partitioning:} Separate Tabellen je Prädikat zur Effizienzsteigerung.
    \item \textbf{Property Tables:} Gruppierung häufig gemeinsam auftretender Prädikate.
    \item \textbf{Hexastore:} Speicherung aller 6 Permutationen von S-P-O zur Beschleunigung von Joins.
\end{itemize}

Diese Strukturen bestimmen maßgeblich die Optimierbarkeit von SPARQL-Anfragen und beeinflussen sowohl den Planungsaufwand als auch die Ausführungsgeschwindigkeit.

% ---------------------- Kapitel 4 ------------------------
\section{Optimierungsprobleme in RDF-Datenbanken} \label{sec:probleme}

Im Vergleich zu klassischen relationalen Datenbanksystemen stellt das RDF-Datenmodell die Anfrageoptimierung vor neuartige Herausforderungen. Diese resultieren sowohl aus der schemalosen und semistrukturierten Natur von RDF als auch aus der offenen Semantik, wie sie durch die Open World Assumption (OWA) definiert wird. In diesem Kapitel werden zentrale Optimierungsprobleme analysiert, die bei der Ausführung von SPARQL-Anfragen in RDF-Datenbanken typischerweise auftreten.

\subsection{Fehlende Schemata und begrenzte Ontologien}

RDF-Datenbanken verfügen typischerweise über kein fixes, global definiertes Schema. Im Gegensatz zu relationalen Datenbanken, in denen die Struktur der Daten über Tabellen- und Attributdefinitionen klar vorgegeben ist, liegt RDF-Daten meist keine explizite Schemadefinition zugrunde. Zwar können optionale semantische Erweiterungen durch Ontologien in RDFS oder OWL eingebunden werden, doch sind diese in der Praxis häufig zu generisch, unvollständig oder nicht konsistent gepflegt. Dadurch fehlen dem Optimierer wesentliche Informationen, etwa über Kardinalitäten, Schlüssel oder Typverteilungen \cite{harth2010sparqling}.

\subsection{Hohe Joindichte bei einfachen Anfragen}

Ein charakteristisches Merkmal von SPARQL-Anfragen ist ihre Joindichte: Selbst einfache Informationsabfragen bestehen aus mehreren Tripelmustern, die über Variablen verknüpft sind. So entspricht z.\,B. eine Abfrage wie „Welche Autoren haben Bücher veröffentlicht, die 2020 erschienen sind?“ bereits einem mehrstufigen Join über die Tripel \texttt{(?book dc:creator ?author)}, \texttt{(?book dc:date ?year)} und \texttt{FILTER (?year = 2020)}. In relationalen Datenbanken könnten solche Informationen in einer einzigen, gut indizierten Tabelle abgefragt werden, während RDF-Systeme mehrere Tripelrelationen verbinden müssen.

Die effiziente Bestimmung der optimalen Join-Reihenfolge ist bei hoher Joindichte besonders anspruchsvoll, da die Anzahl möglicher Join-Bäume exponentiell mit der Anzahl der Tripelpattern wächst \cite{gubichev2013sparql}.

\subsection{Fehlende Kardinalitätsabschätzungen}

Ein zentrales Problem bei der Optimierung ist die fehlende oder ungenaue Schätzung der Kardinalitäten einzelner Tripelpattern. Während relationale Optimierer häufig auf detaillierte Statistiken über Werteverteilungen, Indizes und Histogramme zurückgreifen können, sind entsprechende Metainformationen in RDF-Systemen selten vorhanden oder ungenau. Dies liegt u.\,a. an der extrem heterogenen Nutzung von Prädikaten und an der typischen „long tail“-Verteilung von Vokabularen – viele Prädikate treten sehr selten auf, während wenige sehr häufig vorkommen \cite{stahl2012rdf}.

Falsche Kardinalitätsschätzungen führen in kostenbasierten Optimierern regelmäßig zu suboptimalen Ausführungsplänen, insbesondere bei mehrfach geschachtelten Joins oder OPTIONAL-Konstrukten.

\subsection{Einfluss der Open World Assumption (OWA)}

Die OWA wirkt sich fundamental auf Optimierungsstrategien aus. Da das Fehlen einer Aussage nicht bedeutet, dass sie falsch ist, sind Optimierungen wie Filter-Pushdown, Join-Eliminierung oder Ergebnisvorhersage nur eingeschränkt anwendbar. Besonders bei OPTIONAL-Blöcken ist die semantische Bedeutung komplex: Das Weglassen eines Tripels kann valide sein, auch wenn dadurch keine vollständige Bindung entsteht. Optimierer müssen also Worst-Case-Szenarien einkalkulieren, was zu konservativen und ineffizienten Plänen führen kann.

\subsection{Komplexe SPARQL-Konstrukte: OPTIONAL, FILTER, UNION}

SPARQL bietet mit Konstrukten wie \texttt{OPTIONAL}, \texttt{FILTER} und \texttt{UNION} mächtige Ausdrucksmittel, die jedoch die Optimierung erheblich erschweren. OPTIONAL erzeugt implizit einen left outer join, wodurch bestimmte Join-Reihenfolgen ausgeschlossen werden. FILTER-Ausdrücke, insbesondere wenn sie auf BIND-Ergebnisse oder externe Funktionen zugreifen, lassen sich häufig nicht vorziehen oder aufteilen. UNIONs hingegen führen zu mehrfachen Teilplänen mit potenziell überlappenden Ergebnissen.

Ein einfaches Beispiel ist eine Anfrage nach Geburtsdaten oder Sterbedaten prominenter Persönlichkeiten:

\begin{lstlisting}[caption=Beispiel: OPTIONAL-Abfrage in SPARQL]
SELECT ?person ?birth ?death WHERE {
  ?person dbo:birthDate ?birth .
  OPTIONAL { ?person dbo:deathDate ?death . }
}
\end{lstlisting}

Ein naiver Optimierer könnte das OPTIONAL-Muster ungünstig an den Anfang des Ausführungsplans setzen, was zu deutlich schlechterer Performance führt.

\subsection{Strukturelle Probleme: Blank Nodes und Named Graphs}

Blank Nodes – also Ressourcen ohne URI – erschweren das Identifizieren und Joins über Entitäten. Da sie nicht global referenzierbar sind, müssen sie intern durch systemgenerierte Identifikatoren ersetzt werden. Dies erschwert insbesondere Inferenzmechanismen und die Nachverfolgbarkeit von Aussagen.

Named Graphs wiederum erlauben die Gruppierung von Tripeln in kontextuelle Teilgraphen. Zwar bietet dies konzeptionelle Vorteile (z.\,B. zur Provenienz oder Versionierung), doch führt dies in der Optimierung zu zusätzlichem Planungsaufwand, da Anfragen graphübergreifend analysiert werden müssen.

% ---------------------- Kapitel 5 ------------------------


\section{Fazit}
Hier schließt du deine Arbeit ab.

\printbibliography

\end{document}
